/*
 * TIMER_DRIVER.c
 *
 *  Created on: Jul 9, 2021
 *      Author: zoldeyck
 */
#include "Infrastructure/LIB/STD_TYPES.h"
#include "Infrastructure/LIB/Bit Operations.h"
#include "Mcal/DIO/DIO_DRIVER_TypeDef.h"
#include "Mcal/DIO/DIO_DRIVER.h"
#include "TIMER_DRIVER_typedefs.h"
#include "TIMER_DRIVER_PRIV.h"
#include "TIMER_DRIVER.h"


TIM_ERROR_t TIM_Init (TIM_SELECT_t Timer, TIM_CLK_SELECT_t clock,\
		TIMER_MODE_t timer_mode, TIM_CMPMATCH_OUTPUT_t compareMatch_output_mode,\
		uint16_t counterValue, uint16_t compareValue)
{
	TIM_ERROR_t retVal = EXIT_SUCCESFUL;
	if(Timer<=2 && clock<=7 && timer_mode<=3 && compareMatch_output_mode<=3)
	{
		retVal = TIM_MODE_SLCT(Timer, timer_mode);
		DIO_SetPortVal(PORTC, TIM0_Ctrl_REG);
		retVal =TIM_SetTimerPreLoadVal (Timer, counterValue);
		DIO_SetPortVal(PORTC, TIM0_CurrCount_REG);
		retVal =TIM_OC_MODE_SLCT (Timer, compareMatch_output_mode, timer_mode);
		SET_BIT(TIM0_Ctrl_REG,1)
		DIO_SetPortVal(PORTC, TIM0_Ctrl_REG);
//		retVal =TIM_SetTimerOCVal (Timer, counterValue);
//		DIO_SetPortVal();
//		retVal =TIM_CLK_SLCT(Timer, clock);
//		DIO_SetPortVal();

	}
	else
	{
		retVal = EXIT_FAILURE;
	}
	return retVal;
}
TIM_ERROR_t TIM_SetTimerPreLoadVal (TIM_SELECT_t Timer, uint16_t counterValue)
{
	TIM_ERROR_t retVal = EXIT_SUCCESFUL;
	switch(Timer)
			{
			case TIMER0:
				WRITE_REG(TIM0_CurrCount_REG, (uint8_t)counterValue);
				break;
			case TIMER1:
				break;
			case TIMER2:
				break;
			default:
				retVal = EXIT_FAILURE;
			}
	return retVal;
}
TIM_ERROR_t TIM_SetTimerOCVal (TIM_SELECT_t Timer, uint16_t compareValue)
{
	TIM_ERROR_t retVal = EXIT_SUCCESFUL;
	switch(Timer)
			{
			case TIMER0:
				WRITE_REG(TIM0_OutputComp_REG, (uint8_t)compareValue);
				break;
			case TIMER1:
				break;
			case TIMER2:
				break;
			default:
				retVal = EXIT_FAILURE;
			}
	return retVal;
}
TIM_ERROR_t TIM_SetTimerOVFAction (TIM_SELECT_t Timer, void(*callback)(void))
{
	TIM_ERROR_t retVal;
	switch(Timer)
			{
			case TIMER0:
				if(callback != NULL)
				{
					TIM0_OVFAction_callback = callback;
				}
				else
				{
					retVal = EXIT_FAILURE;
				}
				break;
			case TIMER1:
				break;
			case TIMER2:
				break;
			default:
				retVal = EXIT_FAILURE;
			}
	return retVal;
}
TIM_ERROR_t TIM_SetTimerOCAction (TIM_SELECT_t Timer, void(*callback)(void))
{
	TIM_ERROR_t retVal;
	switch(Timer)
			{
			case TIMER0:
				if(callback != NULL)
				{
					TIM0_OCAction_callback = callback;
				}
				else
				{
					retVal = EXIT_FAILURE;
				}
				break;
			case TIMER1:
				break;
			case TIMER2:
				break;
			default:
				retVal = EXIT_FAILURE;
			}
	return retVal;
}
TIM_ERROR_t TIM_MODE_SLCT(TIM_SELECT_t Timer, TIMER_MODE_t mode)
{
	TIM_ERROR_t retVal = EXIT_SUCCESFUL;
	switch(Timer)
	{
		case TIMER0:
			switch(mode)
			{
				case  Normal:
					MODIFY_REG(TIM0_Ctrl_REG, TIM0_MODE_SELECT_CLRMSK, TIM0_Normal_SETMSK);
					break;
				case  CLR_Timer_OnCompare:
					MODIFY_REG(TIM0_Ctrl_REG, TIM0_MODE_SELECT_CLRMSK, TIM0_CLR_Timer_OnCompare_SETMSK);
					break;
				case  PWM_PhaseCorrect:
					MODIFY_REG(TIM0_Ctrl_REG, TIM0_MODE_SELECT_CLRMSK, TIM0_PWM_PhaseCorrect_SETMSK);
					break;
				case  Fast_PWM:
					MODIFY_REG(TIM0_Ctrl_REG, TIM0_MODE_SELECT_CLRMSK, TIM0_Fast_PWM_SETMSK);
					break;
				default:
					retVal = EXIT_FAILURE;
			}
			break;
		case TIMER1:

			break;
		case TIMER2:

			break;
		default:
			retVal = EXIT_FAILURE;
	}
	return retVal;
}
TIM_ERROR_t TIM_CLK_SLCT(TIM_SELECT_t Timer, TIM_CLK_SELECT_t clock)
{
	TIM_ERROR_t retVal = EXIT_SUCCESFUL;
	switch(Timer)
		{
		case TIMER0:
			switch(clock)
				{
				case _NoCLK:
					MODIFY_REG(TIM0_Ctrl_REG, TIM0_CLK_PRSCLR_CTRL_CLRMSK, TIM0_NoCLK_SETMSK);
					break;
				case _SYSCLK:
					MODIFY_REG(TIM0_Ctrl_REG, TIM0_CLK_PRSCLR_CTRL_CLRMSK, TIM0_SYSCLK_SETMSK);
					break;
				case _SYSCLK_DivideBy8:
					MODIFY_REG(TIM0_Ctrl_REG, TIM0_CLK_PRSCLR_CTRL_CLRMSK, TIM0_SYSCLK_DivideBy8_SETMSK);
					break;
				case _SYSCLK_DivideBy64:
					MODIFY_REG(TIM0_Ctrl_REG, TIM0_CLK_PRSCLR_CTRL_CLRMSK, TIM0_SYSCLK_DivideBy64_SETMSK);
					break;
				case _SYSCLK_DivideBy256:
					MODIFY_REG(TIM0_Ctrl_REG, TIM0_CLK_PRSCLR_CTRL_CLRMSK, TIM0_SYSCLK_DivideBy256_SETMSK);
					break;
				case _SYSCLK_DivideBy1024:
					MODIFY_REG(TIM0_Ctrl_REG,TIM0_CLK_PRSCLR_CTRL_CLRMSK, TIM0_SYSCLK_DivideBy1024_SETMSK);
					break;
				case _EXTCLK_FallingEdge:
					MODIFY_REG(TIM0_Ctrl_REG, TIM0_CLK_PRSCLR_CTRL_CLRMSK, TIM0_EXTCLK_FallingEdge_SETMSK);
					break;
				case _EXTCLK_RisingEdge:
					MODIFY_REG(TIM0_Ctrl_REG, TIM0_CLK_PRSCLR_CTRL_CLRMSK, TIM0_EXTCLK_RisingEdge_SETMSK);
					break;
				default:
					retVal = EXIT_FAILURE;
				}
			break;//end case TIMER0
		case TIMER1:

			break;//end case TIMER1
		case TIMER2:

			break;//end case TIMER2
		default:
			retVal = EXIT_FAILURE;
		}
	return retVal;
}
TIM_ERROR_t TIM_OC_MODE_SLCT(TIM_SELECT_t Timer, TIM_CMPMATCH_OUTPUT_t compareMatch_output_mode, TIMER_MODE_t mode)
{
	TIM_ERROR_t retVal = EXIT_SUCCESFUL;
	TIM_Init_OC_PIN(Timer, mode);
	switch(Timer)
		{
		case TIMER0:
			switch(compareMatch_output_mode)
				{
				case CO_DISABLED_MODE:
					MODIFY_REG(TIM0_Ctrl_REG, TIM0_OC0_OUTPUT_CTRL_CLRMSK, TIM0_CO_DISABLED_MODE_SETMSK);
					break;
				case CO_TOGGLE_MODE:
					if(mode == Normal || mode == CLR_Timer_OnCompare)
					{
						MODIFY_REG(TIM0_Ctrl_REG, TIM0_OC0_OUTPUT_CTRL_CLRMSK, TIM0_CO_TOGGLE_MODE_SETMSK);
					}
					else
					{
						retVal = EXIT_FAILURE;
					}
					break;
				case CO_CLEAR_MODE:
					MODIFY_REG(TIM0_Ctrl_REG, TIM0_OC0_OUTPUT_CTRL_CLRMSK, TIM0_CO_CLEAR_MODE_SETMSK);
					break;
				case CO_SET_MODE:
					MODIFY_REG(TIM0_Ctrl_REG, TIM0_OC0_OUTPUT_CTRL_CLRMSK, TIM0_CO_SET_MODE_SETMSK);
					break;
				default:
					retVal = EXIT_FAILURE;
				}
			break;
		case TIMER1:
			break;
		case TIMER2:
			break;
		default:
			retVal = EXIT_FAILURE;
		}
	return retVal;
}
void TIM0_OVF (void)
{
	TIM0_OVFAction_callback();
}
void TIM0_COMP (void)
{
	TIM0_OCAction_callback();
}
TIM_ERROR_t TIM_Interrupt_Enable(TIM_SELECT_t Timer, TIM_Interrupt_t interrupt)
{
	TIM_ERROR_t retVal = EXIT_SUCCESFUL;
	SET_BIT(STATUS_REG, GLOBAL_Interrupt_Enable_BIT);
	switch (Timer)
			{
			case TIMER0:
				switch (interrupt)
				{
				case TIM0OVF:
					SET_BIT(TIMS_InterruptMask_REG, TIM0_OverFlow_Interrupt_Enable_BIT);
					break;
				case TIM0COMP:
					SET_BIT(TIMS_InterruptMask_REG, TIM0_OutputComp_Interrupt_Enable_BIT);
					break;
				default:
					retVal = EXIT_FAILURE;
				}
				break;
			case TIMER1:
				break;
			case TIMER2:
				break;
			default:
				retVal = EXIT_FAILURE;
			}
	return retVal;
}
TIM_ERROR_t TIM_Interrupt_Disable(TIM_SELECT_t Timer, TIM_Interrupt_t interrupt)
{
	TIM_ERROR_t retVal = EXIT_SUCCESFUL;
	switch (Timer)
				{
				case TIMER0:
					switch (interrupt)
					{
					case TIM0OVF:
						CLEAR_BIT(TIMS_InterruptMask_REG, TIM0_OverFlow_Interrupt_Enable_BIT);
						break;
					case TIM0COMP:
						CLEAR_BIT(TIMS_InterruptMask_REG, TIM0_OutputComp_Interrupt_Enable_BIT);
						break;
					default:
						retVal = EXIT_FAILURE;
					}
					break;
				case TIMER1:
					break;
				case TIMER2:
					break;
				default:
					retVal = EXIT_FAILURE;
				}
		return retVal;
}
TIM_FLAG_STAT_t TIM_Flag_Get(TIM_SELECT_t Timer, TIM_Interrupt_t interrupt)
{
	TIM_FLAG_STAT_t retVal = TIM_FLAG_DOWN;
	switch (Timer)
	{
	case TIMER0:
		switch (interrupt)
		{
		case TIM0OVF:
			retVal = READ_BIT(TIMS_InterruptFlag_REG, TIM0_OVF_Interrupt_Flg_BIT);
			break;
		case TIM0COMP:
			retVal = READ_BIT(TIMS_InterruptFlag_REG, TIM0_OC_Interrupt_Flg_BIT);
			break;
		default:
			retVal = EXIT_FAILURE;
		}

		break;
	case TIMER1:
		break;
	case TIMER2:
		break;
	default:
		retVal = EXIT_FAILURE;
	}

	return retVal;
}
TIM_ERROR_t TIM_Flag_Reset(TIM_SELECT_t Timer, TIM_Interrupt_t interrupt)
{
	TIM_ERROR_t retVal = EXIT_SUCCESFUL;
	switch (Timer)
		{
		case TIMER0:
			switch (interrupt)
			{
			case TIM0OVF:
				retVal = SET_BIT(TIMS_InterruptFlag_REG, TIM0_OVF_Interrupt_Flg_BIT);
				break;
			case TIM0COMP:
				retVal = SET_BIT(TIMS_InterruptFlag_REG, TIM0_OC_Interrupt_Flg_BIT);
				break;
			default:
				retVal = EXIT_FAILURE;
			}

			break;
		case TIMER1:
			break;
		case TIMER2:
			break;
		default:
			retVal = EXIT_FAILURE;
		}
	return retVal;
}
TIM_ERROR_t TIM_Init_OC_PIN(TIM_SELECT_t Timer, TIM_CMPMATCH_OUTPUT_t compareMatch_output_mode)
{
	TIM_ERROR_t retVal = EXIT_SUCCESFUL;
	switch(Timer)
			{
			case TIMER0:
				if(compareMatch_output_mode != CO_DISABLED_MODE)
				{
					retVal = DIO_PinInit(PORTB, PIN3, PIN_OUTPUT);
				}
				else
				{
					retVal = EXIT_FAILURE;
				}
				break;
			case TIMER1:
				break;
			case TIMER2:
				break;
			default:
				retVal = EXIT_FAILURE;
			}
	return retVal;
}

//TIM_ERROR_t TIM_Delay_US(Delay_value_t delayVal)
//{
//	TIM_ERROR_t retVal;
////TCNT=255-(CPUfreq*REq.timedelay)/prescalar
//	return retVal;
//}
//TIM_ERROR_t TIM_Delay_MS(Delay_value_t delayVal)
//{
//	TIM_ERROR_t retVal;
////TCNT=255-(CPUfreq*REq.timedelay)/prescalar
//	return retVal;
//}
