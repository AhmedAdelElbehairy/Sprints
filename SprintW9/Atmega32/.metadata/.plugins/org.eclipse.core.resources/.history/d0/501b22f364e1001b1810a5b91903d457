/*
 * TIMER_DRIVER.c
 *
 *  Created on: Jul 9, 2021
 *      Author: zoldeyck
 */
#include"Infrastructure/LIB/STD_TYPES.h"
#include"Infrastructure/LIB/Bit Operations.h"
#include "TIMER_DRIVER_typedefs.h"
#include "TIMER_DRIVER_PRIV.h"
#include "TIMER_DRIVER.h"


TIM_ERROR_t TIM_Init (TIM_SELECT_t Timer, CLK_SELECT_t clock,\
		TIMER_MODE_t timer_mode, CMPMATCH_OUTPUT_t compareMatch_output_mode,\
		uint16_t counterValue, uint16_t compareValue)
{
	TIM_ERROR_t retVal = EXIT_SUCCESFUL;
	if(Timer<=2 && clock<=7 && timer_mode<=3 && compareMatch_output_mode<=3)
	{
		TIM_MODE_SLCT(Timer, timer_mode);
		TIM_SetTimerPreLoadVal (Timer, counterValue);
		TIM_OC_MODE_SLCT (Timer, compareMatch_output_mode);
		TIM_SetTimerOCVal (Timer, counterValue);
		TIM_CLK_SLCT(Timer, clock);

	}
	else
	{
		retVal = EXIT_FAILURE;
	}
	return retVal;
}
TIM_ERROR_t TIM_SetTimerPreLoadVal (TIM_SELECT_t Timer, uint16_t counterValue)
{
	TIM_ERROR_t retVal;
	switch(Timer)
			{
			case TIMER0:
				WRITE_REG(TIM0_CurrCount_REG, (uint8_t)counterValue);
				break;
			case TIMER1:
				break;
			case TIMER2:
				break;
			default:
				retVal = EXIT_FAILURE;
			}
	return retVal;
}
TIM_ERROR_t TIM_SetTimerOCVal (TIM_SELECT_t Timer, uint16_t compareValue)
{
	TIM_ERROR_t retVal;
	switch(Timer)
			{
			case TIMER0:
				WRITE_REG(TIM0_OutputComp_REG, (uint8_t)compareValue);
				break;
			case TIMER1:
				break;
			case TIMER2:
				break;
			default:
				retVal = EXIT_FAILURE;
			}
	return retVal;
}
TIM_ERROR_t TIM_SetTimerOVFAction (TIM_SELECT_t Timer, void(*callback)(void))
{
	TIM_ERROR_t retVal;
	switch(Timer)
			{
			case TIMER0:
				if(callback != NULL)
				{
					TIM0_OVFAction_callback = callback;
				}
				else
				{
					retVal = EXIT_FAILURE;
				}
				break;
			case TIMER1:
				break;
			case TIMER2:
				break;
			default:
				retVal = EXIT_FAILURE;
			}
	return retVal;
}
TIM_ERROR_t TIM_SetTimerOCAction (TIM_SELECT_t Timer, void(*callback)(void))
{
	TIM_ERROR_t retVal;
	switch(Timer)
			{
			case TIMER0:
				if(callback != NULL)
				{
					TIM0_OCAction_callback = callback;
				}
				else
				{
					retVal = EXIT_FAILURE;
				}
				break;
			case TIMER1:
				break;
			case TIMER2:
				break;
			default:
				retVal = EXIT_FAILURE;
			}
	return retVal;
}
TIM_ERROR_t TIM_MODE_SLCT(TIM_SELECT_t Timer, TIMER_MODE_t mode)
{
	TIM_ERROR_t retVal = EXIT_SUCCESFUL;
	switch(Timer)
	{
		case TIMER0:
			switch(mode)
			{
				case  Normal:
					MODIFY_REG(TIM0_Ctrl_REG, TIM0_MODE_SELECT_CLRMSK, TIM0_Normal_SETMSK);
					break;
				case  CLR_Timer_OnCompare:
					MODIFY_REG(TIM0_Ctrl_REG, TIM0_MODE_SELECT_CLRMSK, TIM0_CLR_Timer_OnCompare_SETMSK);
					break;
				case  PWM_PhaseCorrect:
					MODIFY_REG(TIM0_Ctrl_REG, TIM0_MODE_SELECT_CLRMSK, TIM0_PWM_PhaseCorrect_SETMSK);
					break;
				case  Fast_PWM:
					MODIFY_REG(TIM0_Ctrl_REG, TIM0_MODE_SELECT_CLRMSK, TIM0_Fast_PWM_SETMSK);
					break;
				default:
					retVal = EXIT_FAILURE;
			}
			break;
		case TIMER1:

			break;
		case TIMER2:

			break;
		default:
			retVal = EXIT_FAILURE;
	}
	return retVal;
}
TIM_ERROR_t TIM_CLK_SLCT(TIM_SELECT_t Timer, CLK_SELECT_t clock)
{
	TIM_ERROR_t retVal = EXIT_SUCCESFUL;
	switch(Timer)
		{
		case TIMER0:
			switch(clock)
				{
				case _NoCLK:
					MODIFY_REG(TIM0_Ctrl_REG, TIM0_CLK_PRSCLR_CTRL_CLRMSK, TIM0_NoCLK_SETMSK);
					break;
				case _SYSCLK:
					MODIFY_REG(TIM0_Ctrl_REG, TIM0_CLK_PRSCLR_CTRL_CLRMSK, TIM0_SYSCLK_SETMSK);
					break;
				case _SYSCLK_DivideBy8:
					MODIFY_REG(TIM0_Ctrl_REG, TIM0_CLK_PRSCLR_CTRL_CLRMSK, TIM0_SYSCLK_DivideBy8_SETMSK);
					break;
				case _SYSCLK_DivideBy64:
					MODIFY_REG(TIM0_Ctrl_REG, TIM0_CLK_PRSCLR_CTRL_CLRMSK, TIM0_SYSCLK_DivideBy64_SETMSK);
					break;
				case _SYSCLK_DivideBy256:
					MODIFY_REG(TIM0_Ctrl_REG, TIM0_CLK_PRSCLR_CTRL_CLRMSK, TIM0_SYSCLK_DivideBy256_SETMSK);
					break;
				case _SYSCLK_DivideBy1024:
					MODIFY_REG(TIM0_Ctrl_REG,TIM0_CLK_PRSCLR_CTRL_CLRMSK, TIM0_SYSCLK_DivideBy1024_SETMSK);
					break;
				case _EXTCLK_FallingEdge:
					MODIFY_REG(TIM0_Ctrl_REG, TIM0_CLK_PRSCLR_CTRL_CLRMSK, TIM0_EXTCLK_FallingEdge_SETMSK);
					break;
				case _EXTCLK_RisingEdge:
					MODIFY_REG(TIM0_Ctrl_REG, TIM0_CLK_PRSCLR_CTRL_CLRMSK, TIM0_EXTCLK_RisingEdge_SETMSK);
					break;
				default:
					retVal = EXIT_FAILURE;
				}
			break;//end case TIMER0
		case TIMER1:

			break;//end case TIMER1
		case TIMER2:

			break;//end case TIMER2
		default:
			retVal = EXIT_FAILURE;
		}
	return retVal;
}
TIM_ERROR_t TIM_OC_MODE_SLCT(TIM_SELECT_t Timer, CMPMATCH_OUTPUT_t compareMatch_output_mode)
{
	TIM_ERROR_t retVal = EXIT_SUCCESFUL;
	switch(Timer)
		{
		case TIMER0:
			switch(compareMatch_output_mode)
				{
				case CO_DISABLED_MODE:
					MODIFY_REG(TIM0_Ctrl_REG, TIM0_OC0_OUTPUT_CTRL_CLRMSK, TIM0_CO_DISABLED_MODE_SETMSK);
					break;
				case CO_TOGGLE_MODE:
					MODIFY_REG(TIM0_Ctrl_REG, TIM0_OC0_OUTPUT_CTRL_CLRMSK, TIM0_CO_TOGGLE_MODE_SETMSK);
					break;
				case CO_CLEAR_MODE:
					MODIFY_REG(TIM0_Ctrl_REG, TIM0_OC0_OUTPUT_CTRL_CLRMSK, TIM0_CO_CLEAR_MODE_SETMSK);
					break;
				case CO_SET_MODE:
					MODIFY_REG(TIM0_Ctrl_REG, TIM0_OC0_OUTPUT_CTRL_CLRMSK, TIM0_CO_SET_MODE_SETMSK);
					break;
				default:
					retVal = EXIT_FAILURE;
				}
			break;
		case TIMER1:
			break;
		case TIMER2:
			break;
		default:
			retVal = EXIT_FAILURE;
		}
	return retVal;
}
void TIM0_OVF (void)
{
	TIM0_OVFAction_callback();
}
void TIM0_COMP (void)
{
	TIM0_OCAction_callback();
}
TIM_ERROR_t TIM_Interrupt(TIM_SELECT_t Timer )
//TIM_ERROR_t TIM_Delay_US(Delay_value_t delayVal)
//{
//	TIM_ERROR_t retVal;
////TCNT=255-(CPUfreq*REq.timedelay)/prescalar
//	return retVal;
//}
//TIM_ERROR_t TIM_Delay_MS(Delay_value_t delayVal)
//{
//	TIM_ERROR_t retVal;
////TCNT=255-(CPUfreq*REq.timedelay)/prescalar
//	return retVal;
//}
